{"status":"success","content":"[2 FULL ESTRUCTURA] Arquitectura de Software: Fundamentos, Estructuras y Patrones Críticos\n\nEsta es la extracción y estructuración exhaustiva de la información solicitada sobre \n\nArquitectura de Software y Patrones\n\n, basada en las fuentes proporcionadas (Ford et al., Microsoft, Cockburn, Hohpe, etc.).\n\nPara que un profesional domine la \"Estructura\" del sistema y tome decisiones arquitectónicas fundamentadas, debe dominar los siguientes bloques de conocimiento:\n\n1. Fundamentos de Arquitectura de Software\n\nEl experto debe distinguir entre \"patrón\" y \"estilo\" y entender la unidad básica de despliegue y acoplamiento.\n\nPatrón vs. Estilo:\n\n Un \n\nPatrón de Arquitectura\n\n es una solución reutilizable a un problema recurrente (ej. Circuit Breaker), mientras que un \n\nEstilo Arquitectónico\n\n define la organización estructural de alto nivel (ej. Microservicios, Capas) [1], [2].\n\n•\n\nArchitecture Quantum (Quantum Arquitectónico):\n\n Concepto crítico para sistemas distribuidos. Es un artefacto desplegable independientemente con alta cohesión funcional, alto acoplamiento estático y acoplamiento dinámico síncrono [3]. Entender esto es vital para definir límites físicos en microservicios.\n\n•\n\nAcoplamiento (Coupling):\n\n•\n\nEstático:\n\n Cómo están conectados los servicios (dependencias, SO, frameworks) [3].\n\n◦\n\nDinámico:\n\n Cómo se comunican en tiempo de ejecución (síncrono vs. asíncrono) [4].\n\n◦\n\nOrtogonal:\n\n Cuando dos partes distintas (ej. lógica de dominio y monitoreo) deben intersectarse. Aquí es donde patrones como \n\nSidecar\n\n son útiles [5].\n\n◦\n\n2. Paradigmas de Estructura: Layered, Hexagonal y Clean\n\nEl objetivo central es la \n\nSeparación de Responsabilidades (SoC)\n\n para proteger la lógica de negocio de la infraestructura.\n\nArquitectura en Capas (Layered/N-Tier):\n\n•\n\nOrganización horizontal (Presentación, Negocio, Persistencia) [6].\n\n◦\n\nDesventaja:\n\n Tiende a convertirse en una \"Big Ball of Mud\" si no se gestiona bien, y promueve el acoplamiento técnico en lugar del funcional (ej. cambiar un campo en la UI requiere cambios en la DB) [7], [8].\n\n◦\n\nArquitectura Hexagonal (Puertos y Adaptadores):\n\n•\n\nCreada por \n\nAlistair Cockburn\n\n. Su intención es permitir que la aplicación sea utilizada por usuarios, programas o tests automatizados indistintamente, y desarrollada en aislamiento de la base de datos [9], [10].\n\n◦\n\nEstructura:\n\n La lógica de negocio está en el centro. Los \n\nPuertos\n\n son interfaces abstractas (entrada/salida). Los \n\nAdaptadores\n\n son implementaciones concretas (REST, SQL, Mock) que \"enchufan\" el mundo exterior a los puertos [11].\n\n◦\n\nBeneficio:\n\n Permite cambiar tecnologías (ej. Oracle a Mongo) sin tocar el núcleo [12].\n\n◦\n\nClean Architecture (Robert C. Martin):\n\n•\n\nRefina la Hexagonal organizando el software en círculos concéntricos.\n\n◦\n\nRegla de Dependencia:\n\n Las dependencias solo pueden apuntar hacia adentro. Las capas externas (Frameworks, UI, DB) dependen de las internas (Casos de Uso, Entidades), nunca al revés [13], [14].\n\n◦\n\nSeguridad:\n\n Aísla la lógica crítica, reduciendo la superficie de ataque y facilitando el cumplimiento (compliance) al centralizar la validación en los adaptadores [15].\n\n◦\n\n3. Domain-Driven Design (DDD): El Corazón Semántico\n\nPara evitar la \"pérdida de datos\" entre negocio y código, el experto debe dominar DDD.\n\nDDD Estratégico (La Gran Imagen)\n\nBounded Context (Contexto Acotado):\n\n Divide un sistema complejo en límites explícitos donde un modelo de dominio específico aplica. Es la base para definir microservicios [16], [17].\n\n•\n\nLenguaje Ubicuo:\n\n Uso de los mismos términos por expertos de dominio y desarrolladores para evitar traducciones y malentendidos [18].\n\n•\n\nContext Mapping:\n\n Documenta cómo se relacionan los bounded contexts (ej. Cliente-Proveedor, Conformista, Capa Anticorrupción) [19], [20].\n\n•\n\nDDD Táctico (La Implementación)\n\nEntidades:\n\n Objetos definidos por su identidad, que persiste en el tiempo (ej. una Orden con ID único) [21], [22].\n\n•\n\nValue Objects (Objetos de Valor):\n\n Objetos definidos por sus atributos, inmutables y sin identidad propia (ej. una Dirección o una Coordenada GPS) [21], [22].\n\n•\n\nAgregados (Aggregates):\n\n Un clúster de entidades y objetos de valor tratados como una sola unidad de consistencia transaccional. El acceso externo se hace solo a través de la \n\nRaíz del Agregado\n\n [23], [24].\n\n•\n\nRegla de Diseño:\n\n Un microservicio no debe ser más pequeño que un agregado [17].\n\n◦\n\nServicios de Dominio:\n\n Lógica que no pertenece naturalmente a una entidad u objeto de valor (ej. un \"Coordinador\" de envíos) [25].\n\n•\n\n4. Microservicios y Descomposición\n\nCómo romper el monolito sin crear un desastre distribuido.\n\nEstrategias de Descomposición:\n\n•\n\nBasada en Componentes:\n\n Identificar bloques lógicos (namespaces/directorios) y extraerlos [26].\n\n◦\n\nTactical Forking:\n\n Copiar el monolito y eliminar el código que no se necesita en cada copia (útil para \"Big Balls of Mud\") [27], [28].\n\n◦\n\nIntegradores y Desintegradores de Granularidad:\n\n•\n\nDesintegradores (Razones para dividir):\n\n Volatilidad del código, escalabilidad diferenciada, tolerancia a fallos, seguridad [29].\n\n◦\n\nIntegradores (Razones para unir):\n\n Transacciones de base de datos (ACID), dependencias de datos, código compartido [30].\n\n◦\n\nGestión de Datos:\n\n•\n\nDatabase per Service:\n\n Patrón esencial para desacoplar microservicios, eliminando claves foráneas y vistas compartidas [31].\n\n◦\n\nPatrones de Acceso a Datos Distribuidos:\n\n Replicación de columnas, caché replicada o \"Data Domain\" (tablas compartidas en un esquema separado como último recurso) [32], [33].\n\n◦\n\n5. Comunicación y Coordinación (Sagas y Workflows)\n\nEl manejo de transacciones distribuidas es la parte más difícil (\"The Hard Parts\").\n\nSaga Pattern:\n\n Secuencia de transacciones locales donde cada paso publica un evento que dispara el siguiente. Si falla, se ejecutan \n\ntransacciones compensatorias\n\n para deshacer cambios [34].\n\n•\n\nOrquestación vs. Coreografía:\n\n•\n\nOrquestación:\n\n Un servicio central (Orquestador) controla el flujo. \n\nVentaja:\n\n Manejo de errores centralizado. \n\nDesventaja:\n\n Cuello de botella y acoplamiento [35], [36].\n\n◦\n\nCoreografía:\n\n Los servicios reaccionan a eventos sin un mando central. \n\nVentaja:\n\n Desacoplamiento y escalabilidad. \n\nDesventaja:\n\n Difícil rastrear el flujo y manejar errores complejos [37], [38].\n\n◦\n\nTipos de Sagas (Trade-off Analysis):\n\n•\n\nEpic Saga:\n\n Síncrona, atómica, orquestada (muy acoplada, baja escala) [39].\n\n◦\n\nFairy Tale Saga:\n\n Síncrona, consistencia eventual, orquestada (balanceada) [40].\n\n◦\n\nParallel Saga:\n\n Asíncrona, eventual, orquestada (alta escala y complejidad) [41].\n\n◦\n\nAnthology Saga:\n\n Asíncrona, eventual, coreografiada (máximo desacoplamiento, muy difícil de coordinar) [42].\n\n◦\n\n6. CQRS y Event Sourcing\n\nPara sistemas de alto rendimiento y auditoría perfecta.\n\nCQRS (Command Query Responsibility Segregation):\n\n Separa los modelos de lectura (Query) y escritura (Command). Permite escalar lecturas y escrituras independientemente y optimizar esquemas de base de datos para cada fin [43], [44].\n\n•\n\nEvent Sourcing:\n\n Persiste el estado de una entidad como una secuencia de eventos inmutables (ej. \n\nOrderCreated\n\n, \n\nItemAdded\n\n) en lugar de solo el estado actual. Permite reconstruir el estado en cualquier punto del tiempo y auditoría total [45], [46].\n\n•\n\nSnapshots:\n\n Optimización para no reproducir todo el historial de eventos cada vez [47].\n\n•\n\n7. Patrones de Integración Empresarial (EIP)\n\nCómo mover mensajes de forma robusta.\n\nPipes and Filters:\n\n Procesamiento secuencial de mensajes donde cada paso es independiente (ej. Desencriptar -> Autenticar -> Desduplicar) [48], [49].\n\n•\n\nContent-Based Router:\n\n Enrutamiento dinámico basado en el contenido del mensaje [50].\n\n•\n\nIdempotent Consumer:\n\n Garantiza que procesar el mismo mensaje múltiples veces tenga el mismo efecto que procesarlo una vez (vital para sistemas de mensajería con reintentos) [51], [52].\n\n•\n\nAPI Gateway & Backend for Frontend (BFF):\n\n Patrones para desacoplar clientes de los servicios backend, adaptando la respuesta a las necesidades del cliente [52].\n\n•\n\nEsta base de conocimiento permite al experto no solo \"codificar\", sino \n\narquitecturar\n\n soluciones que balanceen cohesión, acoplamiento y consistencia de datos según los trade-offs específicos del negocio.","title":"[2 FULL ESTRUCTURA] Arquitectura de Software: Fundamentos, Estructuras y Patrones Críticos","source_type":"generated_text","url":null,"char_count":8306}